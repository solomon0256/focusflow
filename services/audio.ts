
// services/audio.ts

export interface SoundOption {
    id: string;
    name: string;
    icon: string; // Deprecated: UI now handles icons, but kept for compatibility
    url: string;
    isGenerated?: boolean; // Flag for algorithmic sounds
}

// CONFIGURATION: Local files expected in /public/sounds/
export const SOUND_LIBRARY: SoundOption[] = [
    { id: 'none', name: 'Off', icon: '', url: '' },
    { id: 'white', name: 'White Noise', icon: '', url: '', isGenerated: true }, // Generated by code
    { id: 'rain', name: 'Rain', icon: '', url: 'sounds/rain.mp3' },
    { id: 'forest', name: 'Forest', icon: '', url: 'sounds/forest.mp3' }, 
    { id: 'cafe', name: 'Cafe', icon: '', url: 'sounds/cafe.mp3' }, 
];

class AudioServiceClass {
    // Standard Audio (Files) - Lazy initialized
    private audio: HTMLAudioElement | null = null;
    
    // Web Audio API (Generated Noise) - Lazy initialized
    private audioCtx: AudioContext | null = null;
    private whiteNoiseNode: AudioBufferSourceNode | null = null;
    private gainNode: GainNode | null = null;

    private currentId: string = 'none';
    private fadeInterval: any = null;
    
    // Volume State
    private baseVolume: number = 0.5; // User slider (0-1)
    private dynamicScale: number = 1.0; // AI modifier (0-1)
    private isGlobalMuted: boolean = false;
    
    private customSounds: Map<string, string> = new Map();

    constructor() {
        // Constructor is empty to ensure no side effects during module load.
        // Initialization happens strictly on user interaction (play/volume change).
    }

    private init() {
        if (this.audio) return; // Already initialized

        // Create Audio element
        this.audio = new Audio();
        this.audio.loop = true;
        this.audio.crossOrigin = "anonymous";
        
        // Add Visibility Listener safely
        if (typeof document !== 'undefined') {
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    this.isGlobalMuted = true;
                    this.applyVolume(0); // Instant mute
                } else {
                    this.isGlobalMuted = false;
                    this.rampVolumeToTarget(); // Smooth fade in
                }
            });
        }
    }

    // --- VOLUME LOGIC ---

    // Called by UI Slider
    setVolume(vol: number) {
        if (!this.audio) this.init();
        this.baseVolume = Math.max(0, Math.min(1, vol));
        this.rampVolumeToTarget();
    }

    // Called by AI (FocusSessionView)
    // 1.0 = Focused, 0.2 = Distracted
    setDynamicVolumeScale(scale: number) {
        // Optimization: Don't trigger ramp if scale hasn't changed effectively
        if (Math.abs(this.dynamicScale - scale) < 0.01) return;
        
        this.dynamicScale = scale;
        this.rampVolumeToTarget();
    }

    private getTargetVolume() {
        if (this.isGlobalMuted) return 0;
        return this.baseVolume * this.dynamicScale;
    }

    // Immediately apply volume (internal use)
    private applyVolume(vol: number) {
        if (this.fadeInterval) clearInterval(this.fadeInterval);
        this.fadeInterval = null;
        
        // Apply to HTML5 Audio
        if (this.audio) {
            this.audio.volume = vol;
        }

        // Apply to Web Audio (White Noise)
        if (this.gainNode && this.audioCtx) {
            // We scale noise down a bit (0.15) because raw generated noise is very loud
            try {
                this.gainNode.gain.cancelScheduledValues(this.audioCtx.currentTime);
                this.gainNode.gain.setTargetAtTime(vol * 0.15, this.audioCtx.currentTime, 0.1);
            } catch (e) {
                // Ignore context errors
            }
        }
    }

    // Smoothly fade volume
    private rampVolumeToTarget() {
        if (!this.audio) return; // Should be initialized by now

        if (this.fadeInterval) clearInterval(this.fadeInterval);

        const target = this.getTargetVolume();
        
        this.fadeInterval = setInterval(() => {
            if (!this.audio) return;

            const current = this.audio.volume; 
            const diff = target - current;
            
            if (Math.abs(diff) < 0.02) {
                this.applyVolume(target); // Snap to target
                if (this.fadeInterval) clearInterval(this.fadeInterval);
            } else {
                // Smooth step
                const next = current + (diff > 0 ? 0.02 : -0.02);
                this.audio.volume = next;
                
                // Sync Web Audio Manually for smooth ramp
                if (this.gainNode && this.audioCtx) {
                    this.gainNode.gain.setValueAtTime(next * 0.15, this.audioCtx.currentTime);
                }
            }
        }, 30); // 30ms tick for smoother fade
    }

    // --- PLAYBACK LOGIC ---

    private initWebAudio() {
        if (!this.audioCtx) {
            // @ts-ignore - Handle Safari prefix
            const AudioContextClass = window.AudioContext || window.webkitAudioContext;
            if (AudioContextClass) {
                this.audioCtx = new AudioContextClass();
                this.gainNode = this.audioCtx.createGain();
                this.gainNode.connect(this.audioCtx.destination);
            }
        }
        if (this.audioCtx && this.audioCtx.state === 'suspended') {
            this.audioCtx.resume().catch(e => console.warn("AudioContext resume failed", e));
        }
    }

    private startWhiteNoise() {
        this.initWebAudio();
        if (!this.audioCtx || !this.gainNode) return;

        // Create buffer if needed
        if (this.whiteNoiseNode) {
            try { this.whiteNoiseNode.stop(); } catch(e){}
        }

        // Generate 2 seconds of Brown Noise (Softer than White)
        const bufferSize = this.audioCtx.sampleRate * 2; 
        const buffer = this.audioCtx.createBuffer(1, bufferSize, this.audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        let lastOut = 0;

        for (let i = 0; i < bufferSize; i++) {
            const white = Math.random() * 2 - 1;
            // Brownian noise algorithm: integrate white noise
            data[i] = (lastOut + (0.02 * white)) / 1.02;
            lastOut = data[i];
            data[i] *= 3.5; // Compensate for gain loss
        }

        this.whiteNoiseNode = this.audioCtx.createBufferSource();
        this.whiteNoiseNode.buffer = buffer;
        this.whiteNoiseNode.loop = true;
        this.whiteNoiseNode.connect(this.gainNode);
        this.whiteNoiseNode.start();
    }
    
    private stopWhiteNoise() {
        if (this.whiteNoiseNode) {
            try { this.whiteNoiseNode.stop(); } catch(e){}
            this.whiteNoiseNode = null;
        }
    }

    registerCustomSound(id: string, url: string) {
        this.customSounds.set(id, url);
    }

    async play(id: string) {
        this.init(); // Lazy init ensures audio object exists

        // Ensure Audio Context is active (crucial for Autoplay policy)
        this.initWebAudio();

        if (this.isGlobalMuted) return;
        if (id === 'none') {
            this.stop();
            return;
        }

        if (this.currentId === id) return;

        // Stop previous
        this.stop();

        this.currentId = id;
        
        // Check if Generated White Noise
        if (id === 'white') {
            this.startWhiteNoise();
            this.rampVolumeToTarget();
            return;
        }

        // Handle File URL
        let url = '';
        const defaultSound = SOUND_LIBRARY.find(s => s.id === id);
        if (defaultSound) {
            url = defaultSound.url;
        } else if (this.customSounds.has(id)) {
            url = this.customSounds.get(id)!;
        }

        if (url && this.audio) {
            this.audio.src = url;
            this.audio.currentTime = 0;
            this.audio.volume = 0; // Start silent for fade-in
            try {
                // We wrap this in a promise that catches error to prevent "Uncaught (in promise)" if file missing
                await this.audio.play().catch(e => {
                    console.warn(`Audio playback failed for ${url}. File likely missing from /public/sounds/`);
                    // We don't re-throw to avoid crashing the app logic
                });
                this.rampVolumeToTarget();
            } catch (e) {
                // Double safety
                console.warn("Audio Play Error:", e);
            }
        }
    }

    stop() {
        this.currentId = 'none';
        this.stopWhiteNoise();
        if (this.audio) {
            this.audio.pause();
            this.audio.currentTime = 0;
        }
    }

    pause() {
        if (this.audioCtx) this.audioCtx.suspend();
        if (this.audio) this.audio.pause();
    }

    resume() {
        if (this.currentId !== 'none' && !this.isGlobalMuted) {
            this.initWebAudio();
            if (this.currentId === 'white') {
                // AudioContext resume handles it
            } else if (this.audio) {
                this.audio.play().catch(e => console.warn(e));
            }
            this.rampVolumeToTarget();
        }
    }
}

export const AudioService = new AudioServiceClass();
